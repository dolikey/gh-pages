<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>nginx</title>
    <url>/2019/10/21/nginx/</url>
    <content><![CDATA[<blockquote>
<p>Nginx是俄罗斯人用c++编写的十分轻量级的HTTP服务器，同时也能作为邮件服务器、反向代理服务器、静态资源服务器。</p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Nginx以事件驱动的方式编写，所以有非常好的性能，同时也是一个非常高效的反向代理、负载平衡。其拥有匹配Lighttpd的性能，同时还没有Lighttpd的内存泄漏问题。</li>
<li>Nginx专为性能优化而开发，性能是其最重要的考量,实现上非常注重效率 。它支持内核Poll模型，能经受高负载的考验,有报告表明能支持高达 50,000个并发连接数。</li>
<li>Nginx具有很高的稳定性。其它HTTP服务器，当遇到访问的峰值，或者有人恶意发起慢速连接时，也很可能会导致服务器物理内存耗尽频繁交换，失去响应，只能重启服务器。例如当前apache一旦上到200个以上进程，web响应速度就明显非常缓慢了。而Nginx采取了分阶段资源分配技术，使得它的CPU与内存占用率非常低。nginx官方表示保持10,000个没有活动的连接，它只占2.5M内存，所以类似DOS这样的攻击对nginx来说基本上是毫无用处的。就稳定性而言,nginx比lighthttpd更胜一筹。</li>
<li>Nginx支持热部署。它的启动特别容易, 并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动。你还能够在不间断服务的情况下，对软件版本进行进行升级。</li>
<li>……<br>

</li>
</ul>
<h4 id="HTTP基础功能："><a href="#HTTP基础功能：" class="headerlink" title="HTTP基础功能："></a>HTTP基础功能：</h4><ul>
<li>处理静态文件，索引文件以及自动索引；</li>
<li>反向代理加速(无缓存)；</li>
<li>FastCGI，简单的负载均衡和容错；</li>
<li>模块化的结构。过滤器包括gzipping, byte ranges, chunked responses, 以及 SSI-filter 。在SSI过滤器中，到同一个 proxy 或者 FastCGI 的多个子请求并发处理；</li>
<li>SSL 和 TLS SNI 支持；</li>
</ul>
<h4 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h4><h5 id="1-正向代理："><a href="#1-正向代理：" class="headerlink" title="1.正向代理："></a>1.正向代理：</h5><p>用户访问代理服务器。网站对用户不透明。对用户服务。</p>
<h5 id="2-反向代理："><a href="#2-反向代理：" class="headerlink" title="2.反向代理："></a>2.反向代理：</h5><p>用户访问反向代理服务器。但是用户不知道访问的是反向代理服务器多个站点中的哪一个站点。对服务器服务。</p>
<h5 id="3-负载均衡"><a href="#3-负载均衡" class="headerlink" title="3.负载均衡"></a>3.负载均衡</h5><p>nginx 的 upstream目前支持 4 种方式的分配<br>1)、轮询（默认）：每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。<br>2)、weight：指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。<br>2)、ip_hash ：每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。<br>3)、fair（第三方）：按后端服务器的响应时间来分配请求，响应时间短的优先分配。<br>4)、url_hash（第三方）</p>
<h5 id="4-异步非阻塞"><a href="#4-异步非阻塞" class="headerlink" title="4.异步非阻塞"></a>4.异步非阻塞</h5><p>和node类似Nginx 采用了异步非阻塞的方式来处理请求。Nginx 采用的是多 worker 的方式来处理请求，每个 worker 里面只有一个主线程，每个worker线程都继承了高并发的特性。<br>想想 apache 的常用工作方式（apache 也有异步非阻塞版本，但因其与自带某些模块冲突，所以不常用），每个请求会独占一个工作线程，当并发数上到几千时，就同时有几千的线程在处理请求了。这对操作系统来说，是个不小的挑战，线程带来的内存占用非常大，线程的上下文切换带来的 cpu 开销很大，自然性能就上不去了，而这些开销完全是没有意义的。</p>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h4 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h4><p>osx 用homebrew</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install nginx</span><br></pre></td></tr></table></figure>

<h4 id="2-nginx命令"><a href="#2-nginx命令" class="headerlink" title="2.nginx命令"></a>2.nginx命令</h4><table>
<thead>
<tr>
<th>命令</th>
<th>注释</th>
</tr>
</thead>
<tbody><tr>
<td>nginx</td>
<td>启动nginx，按照默认路径</td>
</tr>
<tr>
<td>nginx -t</td>
<td>测试配置正确性、也可查询默认配置路径</td>
</tr>
<tr>
<td>nignx -c 路径</td>
<td>按照指定路径[启动</td>
</tr>
<tr>
<td>nginx -s reload</td>
<td>平滑重启</td>
</tr>
<tr>
<td>nginx -s stop</td>
<td>停止nginx</td>
</tr>
<tr>
<td>nginx -v</td>
<td>显示 nginx 的版本</td>
</tr>
<tr>
<td>nginx -V</td>
<td>nginx 的版本，编译器版本和配置参数。</td>
</tr>
</tbody></table>
<h4 id="3-nginx信号"><a href="#3-nginx信号" class="headerlink" title="3.nginx信号"></a>3.nginx信号</h4><p>启动nginx后会根据配置生成一个master进程和多个worker进程（由参数worker_processes配置，一般为机器cpu核数）master 来管理 worker 进程，所以我们只需要与 master 进程通信就行了。master 进程会接收来自外界发来的信号，再根据信号做不同的事情。所以我们要控制 Nginx，只需要通过 kill 向 master 进程发送信号就行了，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kill -HUP pid</span><br><span class="line">//平滑重启nginx</span><br><span class="line">//pid是nginx的进程</span><br><span class="line">//若在nginx.conf配置了pid文件存放路径则该文件存放的就是Nginx主进程号</span><br><span class="line">//可用路径代替pid ，例如： &apos;/usr/nginx/logs/nginx.pid&apos;</span><br></pre></td></tr></table></figure>

<p>master进程:</p>
<table>
<thead>
<tr>
<th>信号</th>
<th>注释</th>
</tr>
</thead>
<tbody><tr>
<td>TERM, INT</td>
<td>快速关闭</td>
</tr>
<tr>
<td>QUIT</td>
<td>从容关闭</td>
</tr>
<tr>
<td>HUP</td>
<td>重载配置 | 用新的配置开始新的工作进程 | 从容关闭旧的工作进程</td>
</tr>
<tr>
<td>USR1</td>
<td>重新打开日志文件</td>
</tr>
<tr>
<td>USR2</td>
<td>平滑升级可执行程序。</td>
</tr>
<tr>
<td>WINCH</td>
<td>从容关闭工作进程</td>
</tr>
</tbody></table>
<p>worker进程：</p>
<table>
<thead>
<tr>
<th>信号</th>
<th>注释</th>
</tr>
</thead>
<tbody><tr>
<td>TERM, INT</td>
<td>快速关闭</td>
</tr>
<tr>
<td>QUIT</td>
<td>从容关闭</td>
</tr>
<tr>
<td>USR1</td>
<td>重新打开日志文件</td>
</tr>
</tbody></table>
<h2 id="conf配置"><a href="#conf配置" class="headerlink" title="conf配置"></a>conf配置</h2><h4 id="基本参数"><a href="#基本参数" class="headerlink" title="基本参数"></a>基本参数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#运行用户</span><br><span class="line">user nobody;</span><br><span class="line">#启动进程,通常设置成和cpu的数量相等</span><br><span class="line">worker_processes  2;</span><br><span class="line">#nginx pid进程号存储地址</span><br><span class="line">pid        logs/nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    #ulimit -n 一个进程所能够打开的文件的最大数</span><br><span class="line">    #反向代理，最大并发数 worker_connections * worker_processes/2</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>在http节点里添加:<br># 定义负载均衡设备的 Ip及设备状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream myServer &#123;</span><br><span class="line">    server 127.0.0.1:9090 down;</span><br><span class="line">    server 127.0.0.1:8080 weight=2;</span><br><span class="line">    server 127.0.0.1:6060;</span><br><span class="line">    server 127.0.0.1:7070 backup;</span><br><span class="line">    ip_hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在需要使用负载的Server节点下添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proxy_pass http://myServer;</span><br></pre></td></tr></table></figure>

<p><strong>upstream 每个设备的状态:</strong></p>
<ul>
<li>down ：表示单前的server暂时不参与负载</li>
<li>weight ：默认为1.weight越大，负载的权重就越大。</li>
<li>max_fails ：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream 模块定义的错误</li>
<li>fail_timeout：max_fails 次失败后，暂停的时间。</li>
<li>backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。</li>
</ul>
<p><strong>ip_hash</strong><br>使用负载均衡服务器一多就会出现一个问题，那怎么实现多台服务器之间session的共享。其中一个方案就是ip_hash。nginx中的ip_hash能够将某个ip的请求定向到同一台后端，这样一来这个ip下的某个客户端和某个后端就能建立起稳固的session;</p>
<h2 id="nginx-编程"><a href="#nginx-编程" class="headerlink" title="nginx 编程"></a>nginx 编程</h2><h4 id="1-nginx变量"><a href="#1-nginx变量" class="headerlink" title="1.nginx变量"></a>1.nginx变量</h4><p>Nginx 变量的创建和赋值操作发生在全然不同的时间阶段。Nginx 变量的创建只能发生在 Nginx 配置加载的时候，或者说 Nginx 启动的时候；而赋值操作则只会发生在请求实际处理的时候。这意味着不创建而直接使用变量会导致启动失败，同时也意味着我们无法在请求处理时动态地创建新的 Nginx 变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 8080;</span><br><span class="line">    location /foo &#123;</span><br><span class="line">        echo &quot;foo = [$foo]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    location /bar &#123;</span><br><span class="line">        set $foo 32;</span><br><span class="line">        echo &quot;foo = [$foo]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用了标准ngx_rewrite模块的set配置指令对变量\$a进行了赋值操作。特别地，我们把字符串hello world赋给了它。这里我们使用第三方ngx_echo模块的echo配置指令将\$foo变量的值作为当前请求的响应体输出。</p>
<p>我们用curl访问地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/foo&apos;     //foo = []</span><br><span class="line">$ curl &apos;http://localhost:8080/bar&apos;    //foo = [32]</span><br></pre></td></tr></table></figure>

<h4 id="2-Nginx-内建变量"><a href="#2-Nginx-内建变量" class="headerlink" title="2.Nginx 内建变量"></a>2.Nginx 内建变量</h4><p>例如由 ngx_http_core 模块提供的内建变量 $uri，可以用来获取当前请求的 URI（经过解码，并且不含请求参数），而 $request_uri 则用来获取请求最原始的 URI （未经解码，并且包含请求参数）。但是大部分内建变量类似保留值不可被赋值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">   echo &quot;uri = $uri&quot;;</span><br><span class="line">   echo &quot;request_uri = $request_uri&quot;;</span><br><span class="line">   echo &quot;name: $arg_name&quot;;//name不区分大小写</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ curl &quot;http://localhost:8080/test?Name=aaa&quot;</span><br><span class="line"> :uri = /test</span><br><span class="line"> :request_uri = /test</span><br><span class="line"> :name: aaa</span><br><span class="line"></span><br><span class="line">$ curl &quot;http://localhost:8080/test?a=3&amp;b=4&quot;</span><br><span class="line">:uri = /test</span><br><span class="line">:request_uri = /test?a=3&amp;b=4</span><br><span class="line">:name:</span><br></pre></td></tr></table></figure>

<p>也有一些内建变量是支持改写的，其中一个例子是 $args. 这个变量在读取时返回当前请求的 URL 参数串（即请求 URL 中问号后面的部分，如果有的话），而在赋值时可以直接修改参数串:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">   set $orig_a $arg_a;</span><br><span class="line">   set $args &quot;a=5&quot;;</span><br><span class="line">   echo &quot;original a: $orig_a&quot;;</span><br><span class="line">   echo &quot;a: $arg_a&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ curl &apos;http://localhost:8080/test?a=3&apos;</span><br><span class="line">:original a: 3</span><br><span class="line">:a: 5</span><br></pre></td></tr></table></figure>

<p>原本$arg_a应该返回参数a=3，但是访问时赋值了$args ‘a=5’，所以取$arg_a时返回了5；</p>
<blockquote>
<p>参考链接：<br><a href="http://www.ttlsa.com/nginx/nginx-tutorial-from-entry-to-the-master-ttlsa/" target="_blank" rel="noopener">http://www.ttlsa.com/nginx/nginx-tutorial-from-entry-to-the-master-ttlsa/</a><br><a href="https://openresty.org/download/agentzh-nginx-tutorials-zhcn.html" target="_blank" rel="noopener">https://openresty.org/download/agentzh-nginx-tutorials-zhcn.html</a><br><a href="http://wiki.jikexueyuan.com/project/nginx/nginx-framework.html" target="_blank" rel="noopener">http://wiki.jikexueyuan.com/project/nginx/nginx-framework.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>server</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>浮点数计算中的精度丢失</title>
    <url>/2019/10/21/precision/</url>
    <content><![CDATA[<h2 id="1-js浮点数运算精度丢失"><a href="#1-js浮点数运算精度丢失" class="headerlink" title="1  js浮点数运算精度丢失"></a>1  js浮点数运算精度丢失</h2><p>如果你用过js计算浮点数你肯定会遇到过下面这种情况：(我的小学白读了吗==。)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0.2 + 0.4 === 0.6000000000000001</span><br><span class="line">&gt; true</span><br><span class="line"></span><br><span class="line">0.2 + 0.4 === 0.6</span><br><span class="line">&gt; false</span><br></pre></td></tr></table></figure>

<p>（其实不只是js，你用其他的IEEE 754浮点数标准的语言也能遇到相同的问题）</p>
<p>为什么会这样呢？</p>
<p>因为你的浮点数首先要被转化成二进制存储到内存中，然后才被计算。丢失的精度其实是在浮点数转化成二进制时发生的。（你可能还不是特别明白，下面会进一步解释）</p>
<h2 id="2-浮点数转化二进制"><a href="#2-浮点数转化二进制" class="headerlink" title="2 浮点数转化二进制"></a>2 浮点数转化二进制</h2><p>浮点数要怎么转化成二进制？</p>
<p>十进制: ${11.11= 1<em>10^1 + 1</em>10^0 + 1<em>10^{-1} + 1</em>10^{-2}}$</p>
<p>二进制: ${11.11= 1<em>2^1 + 1</em>2^0 + 1<em>2^{-1} + 1</em>2^{-2}}$</p>
<p>十进制1.6要转化成二进制需要分成两部分，</p>
<p>整数部分要做的是： <strong>除2取余</strong><br>1%2 = 1<br>小数部分要做的是：<strong>乘2取整</strong><br>0.6*2 = 1 + 0.2<br>0.2*2 = 0 + 0.4<br>0.4*2 = 0 + 0.8<br>0.8*2 = 1 + 0.6<br>0.6*2 = 1 + 0.2<br>…<br>你会发现得到的二进制1.10011…. 是一个无穷长的无限循环二进制小数。</p>
<p>为什么会这样，其实十进制中的0.5相当于一的一半，类似的二进制中的0.1相当于一的一半。（0-1-2）<br>那十进制0.6代表着二进制中0.1的1/6。<br>所以在0.0到0.9中只有0和0.5有对应具体的二进制表示。</p>
<p>所以答案就出来了，如果你把一个无限循环的二进制数放入不管是32还是64位的系统中肯定是只能取其中的一部分存储，那被截取的一部分就是浮点数计算的时候有时会丢失精度的原因。</p>
<h2 id="3-国际标准IEEE-754"><a href="#3-国际标准IEEE-754" class="headerlink" title="3  国际标准IEEE 754"></a>3  国际标准IEEE 754</h2><p>任意一个二进制浮点数V可以表示成下面的形式：</p>
<p>$$V = {(-1)^S  *  M  *  2^E}$$</p>
<ol>
<li>(-1)^s表示符号位，当s=0，V为正数；当s=1，V为负数。</li>
<li>M表示有效数字，大于等于1，小于2。</li>
<li>2^E表示指数位。</li>
</ol>
<hr>
<p>举例来说:<br>十进制的5.0，写成二进制是101.0，相当于1.01×2^2。那么，按照上面V的格式，可以得出s=0，M=1.01，E=2。<br>十进制的-5.0，写成二进制是-101.0，相当于-1.01×2^2。那么，s=1，M=1.01，E=2。</p>
<h3 id="2-1-内存中的浮点数"><a href="#2-1-内存中的浮点数" class="headerlink" title="2.1  内存中的浮点数"></a>2.1  内存中的浮点数</h3><p>IEEE 754规定，对于32位的浮点数，最高的1位是符号位s，接着的8位是指数E，剩下的23位为有效数字M。对于64位的浮点数，最高的1位是符号位S，接着的11位是指数E，剩下的52位为有效数字M。</p>
<p>IEEE 754规定，在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的xxxxxx部分。</p>
<h3 id="2-2-特殊的指数E"><a href="#2-2-特殊的指数E" class="headerlink" title="2.2 特殊的指数E"></a>2.2 特殊的指数E</h3><p>首先，E为一个无符号整数（unsigned int）。这意味着，如果E为8位，它的取值范围为0<del>255；如果E为11位，它的取值范围为0</del>2047。但是，我们知道，科学计数法中的E是可以出现负数的，所以E的真实值必须再减去一个中间数，对于8位的E，这个中间数是127；对于11位的E，这个中间数是1023。</p>
<p>比如，2^10的E是10，所以保存成32位浮点数时，必须保存成10+127=137，即10001001。</p>
<p>然后，指数E还可以再分成三种情况：</p>
<ul>
<li>E不全为0或不全为1。这时，浮点数就采用上面的规则表示，即指数E的计算值减去127（或1023），得到真实值，再将有效数字M前加上第一位的1。</li>
<li>E全为0。这时，浮点数的指数E等于1-127（或者1-1023），有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数。这样做是为了表示±0，以及接近于0的很小的数字。</li>
<li>E全为1。这时，如果有效数字M全为0，表示±无穷大（正负取决于符号位s）；如果有效数字M不全为0，表示这个数不是一个数（NaN）。</li>
</ul>
<p>参考：<br>[代码之谜（五）- 浮点数（谁偷了你的精度？）] (<a href="http://justjavac.com/codepuzzle/2012/11/11/codepuzzle-float-who-stole-your-accuracy.html" target="_blank" rel="noopener">http://justjavac.com/codepuzzle/2012/11/11/codepuzzle-float-who-stole-your-accuracy.html</a>)<br><a href="http://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html" target="_blank" rel="noopener">浮点数的二进制表示</a></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>eslint 静态代码检测工具</title>
    <url>/2019/10/21/eslint/</url>
    <content><![CDATA[<p>ESLint最初是由Nicholas C. Zakas 于2013年6月创建的开源项目。它的目标是提供一个插件化的javascript代码检测工具。对比于jshint显著的特点就是支持插件拓展还有就是支持jsx语法（jshint并不支持jsx，react开发老报错也是很头疼ㄟ( ▔, ▔ )ㄏ ）。</p>
<h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><p>具体的可以参考这里 <a href="http://eslint.org/docs/user-guide/command-line-interface" target="_blank" rel="noopener">传送门</a> 或者 eslint -h， 这里给出几个常用的。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>使用npm安装，没有npm的点这里<a href="https://www.npmjs.com/" target="_blank" rel="noopener">https://www.npmjs.com/</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i -g eslint</span><br></pre></td></tr></table></figure>

<h3 id="生成配置"><a href="#生成配置" class="headerlink" title="生成配置"></a>生成配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eslint --init</span><br><span class="line">//回答问题后生成eslint配置。</span><br></pre></td></tr></table></figure>

<h3 id="运行eslint"><a href="#运行eslint" class="headerlink" title="运行eslint"></a>运行eslint</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eslint [options] [file|dir|glob]*</span><br><span class="line"></span><br><span class="line">//eslint file1.js file2.js</span><br><span class="line">//eslint lib/**</span><br><span class="line">//eslint &quot;lib/**&quot; glob模式要用引号</span><br></pre></td></tr></table></figure>

<h2 id="eslint配置"><a href="#eslint配置" class="headerlink" title="eslint配置"></a>eslint配置</h2><p>配置有这几种方式：</p>
<ul>
<li>直接在代码文件中定义，使用 JavaScript 注释把配置信息直接嵌入到一个文件。</li>
<li>使用 .eslintrc （json或者YAML）或者 .eslintrc.yml（YAML）或者 .eslintrc.js（javascript）或者 .eslintrc.json （JSON）；</li>
<li>在 package.json 中添加 eslintConfig 字段；</li>
</ul>
<p>和jshint一样有个忽略检测文件的配置.eslintignore。<br>eslintrc执行时会从检测的文件一层层往上找配置文件，但是离检测文件最近的文件优先级最高，会覆盖父级的配置。所以一般会在根目录的配置中加一个：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># YAML</span><br><span class="line">root: true</span><br></pre></td></tr></table></figure>

<p>ESLint 一旦发现配置文件中有 “root”: true，它就会停止在父级目录中寻找。<br>如果项目内没有配置文件，会退回到系统 ~/.eslintrc 中自定义的默认配置。</p>
<p>有很多信息可以被配置：</p>
<ul>
<li>Environments - 指定脚本的运行环境。每种环境都有一组特定的预定义全局变量。</li>
<li>Globals - 脚本在执行期间访问的额外的全局变量。</li>
<li>Rules - 启用的规则及各自的错误级别。</li>
</ul>
<p>一个简单的例子(.eslintrc.yml)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># YAML</span><br><span class="line">env:</span><br><span class="line">  browser: true</span><br><span class="line">parserOptions:</span><br><span class="line">  ecmaVersion: 6</span><br><span class="line">  ecmaFeatures:</span><br><span class="line">    jsx: true</span><br><span class="line">globals :</span><br><span class="line">   angular: true</span><br><span class="line">rules:</span><br><span class="line">  camelcase: 0</span><br><span class="line">  curly: 2</span><br><span class="line">  brace-style:</span><br><span class="line">    - 2</span><br><span class="line">    - 1tbs</span><br><span class="line">  quotes:</span><br><span class="line">    - 2</span><br><span class="line">    - single</span><br><span class="line">  semi:</span><br><span class="line">    - 2</span><br><span class="line">    - always</span><br><span class="line">  space-in-brackets:</span><br><span class="line">    - 2</span><br><span class="line">    - never</span><br><span class="line">  space-infix-ops: 2</span><br></pre></td></tr></table></figure>

<h3 id="1-parserOptions-解析器选项"><a href="#1-parserOptions-解析器选项" class="headerlink" title="1.parserOptions 解析器选项"></a>1.parserOptions 解析器选项</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#YAML</span><br><span class="line">parserOptions:</span><br><span class="line">  ecmaVersion: 6</span><br><span class="line">  ecmaFeatures:</span><br><span class="line">    jsx: true</span><br></pre></td></tr></table></figure>

<p>parserOptions 属性设置解析器选项。可用的选项有：</p>
<ul>
<li>ecmaVersion - 设置为 3， 5 (默认)， 6、7 或 8 指定你想要使用的 ECMAScript 版本。你也可以指定为 2015（同 6），2016（同 7），或 2017（同 8）使用年份命名</li>
<li>sourceType - 设置为 “script” (默认) 或 “module”（如果你的代码是 ECMAScript 模块)。</li>
<li>ecmaFeatures - 这是个对象，表示你想使用的额外的语言特性:<ul>
<li>globalReturn - 允许在全局作用域下使用 return 语句</li>
<li>impliedStrict - 启用全局 strict mode (如果 ecmaVersion 是 5 或更高)</li>
<li>jsx - 启用 JSX</li>
<li>experimentalObjectRestSpread - 启用对实验性的 object rest/spread properties 的支持。(重要：这是一个实验性的功能,在未来可能会改变明显。 建议你写的规则 不要依赖该功能，除非当它发生改变时你愿意承担维护成本。)</li>
</ul>
</li>
</ul>
<h3 id="2-env-环境全局变量"><a href="#2-env-环境全局变量" class="headerlink" title="2.env 环境全局变量"></a>2.env 环境全局变量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># YAML</span><br><span class="line">env:</span><br><span class="line">  browser: true</span><br></pre></td></tr></table></figure>

<p>环境定义了预定义的全局变量。可用的环境有：</p>
<ul>
<li>browser - browser 全局变量。</li>
<li>node - Node.js 全局变量和 Node.js 作用域。</li>
<li>commonjs - CommonJS 全局变量和 CommonJS 作用域 (仅为使用 Browserify/WebPack 写的只支持浏览器的代码)。</li>
<li>shared-node-browser - Node 和 Browser 通用全局变量。</li>
<li>es6 - 支持除模块外所有 ECMAScript 6 特性（该选项会自动设置 ecmaVersion 解析器选项为 6）。</li>
<li>worker - web workers 全局变量。</li>
<li>amd - 定义 require() 和 define() 作为像 amd 一样的全局变量。</li>
<li>mocha - 添加所有的 Mocha 测试全局变量。</li>
<li>jasmine - 添加所有的 Jasmine 版本 1.3 和 2.0 的测试全局变量。</li>
<li>jest - Jest 全局变量。</li>
<li>phantomjs - PhantomJS 全局变量。</li>
<li>protractor - Protractor 全局变量。</li>
<li>qunit - QUnit 全局变量。</li>
<li>jquery - jQuery 全局变量。</li>
<li>prototypejs - Prototype.js 全局变量。</li>
<li>shelljs - ShellJS 全局变量。</li>
<li>meteor - Meteor 全局变量。</li>
<li>mongo - MongoDB 全局变量。</li>
<li>applescript - AppleScript 全局变量。</li>
<li>nashorn - Java 8 Nashorn 全局变量。</li>
<li>serviceworker - Service Worker 全局变量。</li>
<li>atomtest - Atom 测试全局变量。</li>
<li>embertest - Ember 测试全局变量。</li>
<li>webextensions - WebExtensions 全局变量。</li>
<li>greasemonkey - GreaseMonkey 全局变量。</li>
</ul>
<h3 id="3-globals全局变量"><a href="#3-globals全局变量" class="headerlink" title="3.globals全局变量"></a>3.globals全局变量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># YAML</span><br><span class="line">globals :</span><br><span class="line">   angular: true</span><br><span class="line">   var1: true</span><br><span class="line">   var2: false</span><br></pre></td></tr></table></figure>

<p>当访问未定义的变量时，no-undef 规则将发出警告。如果你想在一个文件里使用全局变量，推荐你定义这些全局变量，这样 ESLint 就不会发出警告了。你可以使用注释或在配置文件中定义全局变量。</p>
<h3 id="4-plugins-插件"><a href="#4-plugins-插件" class="headerlink" title="4.plugins 插件"></a>4.plugins 插件</h3><p>ESLint 支持使用第三方插件。在使用插件之前，你必须使用 npm 安装它。<br>在配置文件里配置插件，要使用 plugins ，其中包含插件名字的列表。插件名称可以省略 eslint-plugin- 前缀。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># YAML</span><br><span class="line">plugins:</span><br><span class="line">    - plugin1</span><br><span class="line">    - eslint-plugin-plugin2</span><br></pre></td></tr></table></figure>

<p>注意：全局安装的 ESLint 只能使用全局安装的插件。本地安装的 ESLint 不仅可以使用本地安装的插件还可以使用全局安装的插件。</p>
<h3 id="5-Rules-规则"><a href="#5-Rules-规则" class="headerlink" title="5.Rules 规则"></a>5.Rules 规则</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugins:</span><br><span class="line">  - plugin1</span><br><span class="line">rules:</span><br><span class="line">  curly: 2</span><br><span class="line">  brace-style:</span><br><span class="line">    - 2</span><br><span class="line">    - 1tbs</span><br><span class="line">  quotes:</span><br><span class="line">    - 2</span><br><span class="line">    - single</span><br><span class="line">  plugin1/rule1 : error</span><br><span class="line">  #配置定义在插件中的一个规则的时候，你必须使用 插件名/规则ID 的形式</span><br></pre></td></tr></table></figure>

<p>ESLint 附带有大量的规则。你可以使用注释或配置文件修改你项目中要使用哪些规则。改变一个规则设置，你必须设置规则 ID 等于这些值之一：</p>
<ul>
<li>“off” 或 0 - 关闭规则</li>
<li>“warn” 或 1 - 开启规则，使用警告级别的错误：warn (不会导致程序退出)</li>
<li>“error” 或 2 - 开启规则，使用错误级别的错误：error (当被触发的时候，程序会退出)</li>
</ul>
<p>具体的规则太多了这一看这里 ： <a href="http://eslint.cn/docs/rules/" target="_blank" rel="noopener">传送门</a></p>
<h3 id="6-共享设置"><a href="#6-共享设置" class="headerlink" title="6.共享设置"></a>6.共享设置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># YAML</span><br><span class="line">settings:</span><br><span class="line">    sharedData: &quot;Hello&quot;</span><br></pre></td></tr></table></figure>

<p>ESLint 支持在配置文件添加共享设置。你可以添加 settings 对象到配置文件，它将提供给每一个将被执行的规则。如果你想添加的自定义规则而且使它们可以访问到相同的信息，这将会很有用，并且很容易配置。</p>
<h3 id="行内配置"><a href="#行内配置" class="headerlink" title="*行内配置"></a>*行内配置</h3><h4 id="禁止eslint检测"><a href="#禁止eslint检测" class="headerlink" title="禁止eslint检测"></a>禁止eslint检测</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//1.禁止规则出现警告</span><br><span class="line">/* eslint-disable */</span><br><span class="line">alert(&apos;foo&apos;);</span><br><span class="line">/* eslint-enable */</span><br><span class="line"></span><br><span class="line">//.2或者对指定的规则启用或禁用警告</span><br><span class="line">/* eslint-disable no-alert, no-console */</span><br><span class="line">alert(&apos;foo&apos;);</span><br><span class="line">console.log(&apos;bar&apos;);</span><br><span class="line">/* eslint-enable no-alert, no-console */</span><br><span class="line"></span><br><span class="line">//3.整个文件范围内禁止规则出现警告,将 /* eslint-disable */ 块注释放在文件顶部</span><br><span class="line"></span><br><span class="line">//4.你也可以对整个文件启用或禁用警告:</span><br><span class="line">/* eslint-disable no-alert */</span><br><span class="line">// Disables no-alert for the rest of the file</span><br><span class="line"></span><br><span class="line">//5.单行注释</span><br><span class="line">alert(&apos;foo&apos;); // eslint-disable-line</span><br><span class="line">// eslint-disable-next-line</span><br><span class="line">alert(&apos;foo&apos;);</span><br></pre></td></tr></table></figure>

<h3 id="配置文件的继承"><a href="#配置文件的继承" class="headerlink" title="*配置文件的继承"></a>*配置文件的继承</h3><p>一个配置文件可以被基础配置中的已启用的规则继承</p>
<h4 id="1-eslint-recommended"><a href="#1-eslint-recommended" class="headerlink" title="1 eslint:recommended"></a>1 eslint:recommended</h4><p>值为 “eslint:recommended” 的 extends 属性启用一系列核心规则，这些规则报告一些常见问题，在 规则页面 中被标记为  。这个推荐的子集只能在 ESLint 主要版本进行更新。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># YAML</span><br><span class="line">extends: eslint:recommended,</span><br><span class="line">rules :</span><br><span class="line">  #enable additional rules</span><br><span class="line">  indent:</span><br><span class="line">    - error</span><br><span class="line">    - 4</span><br></pre></td></tr></table></figure>

<h4 id="2-extend-npm包"><a href="#2-extend-npm包" class="headerlink" title="2 extend npm包"></a>2 extend npm包</h4><p>继承的可以是一个 npm 包，它输出一个配置对象。要确保这个包安装在 ESLint 能请求到的目录下。extends 属性值可以省略包名的前缀 eslint-config-。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># YAML</span><br><span class="line">extends: standard</span><br><span class="line">rules:</span><br><span class="line">  comma-dangle:</span><br><span class="line">    - error</span><br><span class="line">    - always</span><br><span class="line">  no-empty: warn</span><br></pre></td></tr></table></figure>

<h4 id="3-plugins-npm包"><a href="#3-plugins-npm包" class="headerlink" title="3 plugins npm包"></a>3 plugins npm包</h4><p>一些插件也可以输出一个或多个命名的 配置。要确保这个包安装在 ESLint 能请求到的目录下。plugins 属性值 可以省略包名的前缀 eslint-plugin-。<br>extends 属性值可以由以下组成：</p>
<ul>
<li>plugin:</li>
<li>包名 (省略了前缀，比如，react)</li>
<li>/</li>
<li>配置名称 (比如 recommended)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># JSON</span><br><span class="line">&#123;</span><br><span class="line">    &quot;plugins&quot;: [</span><br><span class="line">        &quot;react&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;extends&quot;: [</span><br><span class="line">        &quot;eslint:recommended&quot;,</span><br><span class="line">        &quot;plugin:react/recommended&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;rules&quot;: &#123;</span><br><span class="line">       &quot;no-set-state&quot;: &quot;off&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-继承配置文件"><a href="#4-继承配置文件" class="headerlink" title="4 继承配置文件"></a>4 继承配置文件</h4><p>extends 属性值可以是基本配置文件的绝对路径或相对路径。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;extends&quot;: [</span><br><span class="line">        &quot;./node_modules/coding-standard/eslintDefaults.js&quot;,</span><br><span class="line">        &quot;./node_modules/coding-standard/.eslintrc-es6&quot;,</span><br><span class="line">        &quot;./node_modules/coding-standard/.eslintrc-jsx&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;rules&quot;: &#123;</span><br><span class="line">        &quot;eqeqeq&quot;: &quot;warn&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考<br><a href="http://eslint.cn/" target="_blank" rel="noopener">http://eslint.cn/</a><br><a href="http://eslint.org/docs" target="_blank" rel="noopener">http://eslint.org/docs</a><br><a href="https://csspod.com/getting-started-with-eslint/" target="_blank" rel="noopener">https://csspod.com/getting-started-with-eslint/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>eshint</tag>
      </tags>
  </entry>
  <entry>
    <title>grid 删格布局</title>
    <url>/2019/10/21/grid/</url>
    <content><![CDATA[<blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html" target="_blank" rel="noopener">传送门</a> - <a href="http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html</a> 来自阮一峰的博客，这篇文章作为一个自己学习笔记吧。</p>
</blockquote>
<p>顾名思义就是利用网格结构来布局。<br>正常的盒模型布局，布局结构会相对复杂。且自响应能力较差。于是就出现了flex。和之前相似的就是还是属于一维布局，正常流式布局。而grid就属于网格二维布局，相比之前能够更简单的实现一些布局工作。</p>
<h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><h4 id="容器和项目"><a href="#容器和项目" class="headerlink" title="容器和项目"></a>容器和项目</h4><p>这个和flex类似，grid作用区域叫做容器，容器顶级子元素叫做项目</p>
<h4 id="行（row）和列-（column）"><a href="#行（row）和列-（column）" class="headerlink" title="行（row）和列 （column）"></a>行（row）和列 （column）</h4><p>例：m个row 和 n个col</p>
<h4 id="单元格"><a href="#单元格" class="headerlink" title="单元格"></a>单元格</h4><p>由行和列组成的格子 m*n个</p>
<h4 id="网格线"><a href="#网格线" class="headerlink" title="网格线"></a>网格线</h4><p>围成单元格的线 m+1 和 n+1个</p>
<h2 id="二、容器属性"><a href="#二、容器属性" class="headerlink" title="二、容器属性"></a>二、容器属性</h2><p>行列的大小，边距，对齐方式</p>
<h3 id="1-display"><a href="#1-display" class="headerlink" title="1. display"></a>1. display</h3><p>两种，定义grid布局生效，生效类型的容器属于block还是inline</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">display: grid;</span><br><span class="line">display: inline-grid;</span><br></pre></td></tr></table></figure>

<h3 id="2-grid-template-columns-和-grid-template-rows"><a href="#2-grid-template-columns-和-grid-template-rows" class="headerlink" title="2. grid-template-columns 和 grid-template-rows"></a>2. grid-template-columns 和 grid-template-rows</h3><p><strong>定义每行，每列的大小</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  display: grid;</span><br><span class="line">  // 正常col和row两种，3x3格子的大小</span><br><span class="line">  grid-template-columns: 100px 100px 100px;</span><br><span class="line">  grid-template-rows: 100px 100px 100px;</span><br><span class="line"></span><br><span class="line">  // repeat 两个参数，（重复次数，重复的模式）</span><br><span class="line">  grid-template-columns: repeat(3, 100px);</span><br><span class="line">  grid-template-columns: repeat(2, 100px，50px); // 100px 50px 100px 50px</span><br><span class="line">  grid-template-columns: repeat(auto-fill, 100px); // 自动填满一行</span><br><span class="line"></span><br><span class="line">  // fr fraction缩写，比例片段。</span><br><span class="line">  grid-template-columns: 150px 1fr 2fr; // 150px剩下的区域按1:2分配</span><br><span class="line"></span><br><span class="line">  // minmax 不小于100px不大于1fr</span><br><span class="line">  grid-template-columns: 1fr 1fr minmax(100px, 1fr);</span><br><span class="line"></span><br><span class="line">  // 网格线命名</span><br><span class="line">  grid-template-columns: [c1, header] 100px [c2] 100px [c3] auto [c4];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-grid-gap"><a href="#3-grid-gap" class="headerlink" title="3. grid-gap"></a>3. grid-gap</h3><p>定义边距</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grid-row-gap: 20px;</span><br><span class="line">grid-column-gap: 20px;</span><br><span class="line">grid-gap: &lt;grid-row-gap&gt; &lt;grid-column-gap&gt;; // 先行后列</span><br></pre></td></tr></table></figure>

<h3 id="4-grid-template-areas"><a href="#4-grid-template-areas" class="headerlink" title="4. grid-template-areas"></a>4. grid-template-areas</h3><p>定义区域命名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grid-template-areas: &quot;header header header&quot;</span><br><span class="line">                    &quot;main main sidebar&quot;</span><br><span class="line">                    &quot;footer footer footer&quot;;</span><br></pre></td></tr></table></figure>

<h3 id="5-grid-auto-flow"><a href="#5-grid-auto-flow" class="headerlink" title="5. grid-auto-flow"></a>5. grid-auto-flow</h3><p>定义排列顺序和自动密集排序row dense</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grid-auto-flow: column | row; // 默认row</span><br><span class="line">grid-auto-flow: row dense</span><br></pre></td></tr></table></figure>

<h3 id="6-justify-items-align-items-space-items"><a href="#6-justify-items-align-items-space-items" class="headerlink" title="6. justify-items, align-items, space-items"></a>6. justify-items, align-items, space-items</h3><p>定义容器中项目内容的对齐方式，和flex类似</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">justify-items: start | end | center | stretch;</span><br><span class="line">align-items: start | end | center | stretch;</span><br></pre></td></tr></table></figure>

<h3 id="7-justify-content-align-content-space-content"><a href="#7-justify-content-align-content-space-content" class="headerlink" title="7. justify-content, align-content, space-content"></a>7. justify-content, align-content, space-content</h3><p>定义容器中项目的对齐方式，和flex类似</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">justify-content: start | end | center | stretch | space-around | space-between | space-evenly;</span><br><span class="line">align-content: start | end | center | stretch | space-around | space-between | space-evenly;</span><br></pre></td></tr></table></figure>

<h3 id="8-grid-auto-rows-grid-auto-columns"><a href="#8-grid-auto-rows-grid-auto-columns" class="headerlink" title="8. grid-auto-rows, grid-auto-columns"></a>8. grid-auto-rows, grid-auto-columns</h3><p>超出定义网格区域的单元格大小（默认和template一样）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  display: grid;</span><br><span class="line">  grid-template-columns: 100px 100px 100px;</span><br><span class="line">  grid-template-rows: 100px 100px 100px;</span><br><span class="line">  grid-auto-rows: 50px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-grid-template-和-grid"><a href="#9-grid-template-和-grid" class="headerlink" title="9. grid-template 和 grid"></a>9. grid-template 和 grid</h3><p>grid-template属性是grid-template-columns、grid-template-rows和grid-template-areas这三个属性的合并简写形式。</p>
<p>grid属性是grid-template-rows、grid-template-columns、grid-template-areas、 grid-auto-rows、grid-auto-columns、grid-auto-flow这六个属性的合并简写形式。</p>
<h2 id="三、项目属性"><a href="#三、项目属性" class="headerlink" title="三、项目属性"></a>三、项目属性</h2><p>定位和对齐方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.item-1 &#123;</span><br><span class="line">  // 默认序号</span><br><span class="line">  grid-column-start: 1;</span><br><span class="line">  grid-column-end: 3;</span><br><span class="line">  grid-row-start: 2;</span><br><span class="line">  grid-row-end: 4;</span><br><span class="line"></span><br><span class="line">  // 网格线</span><br><span class="line">  grid-column-start: header-start;</span><br><span class="line">  grid-column-end: header-end;</span><br><span class="line"></span><br><span class="line">  // span 跨行</span><br><span class="line">  grid-column-start: span 2; // 或者grid-column-end: span 2;</span><br><span class="line"></span><br><span class="line">  // 简写</span><br><span class="line">  grid-column:  start / end;</span><br><span class="line">  grid-row:  start / end;</span><br><span class="line"></span><br><span class="line">  grid-area: &lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt;;</span><br><span class="line"></span><br><span class="line">  grid-area: header;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">justify-self: start | end | center | stretch;</span><br><span class="line">align-self: start | end | center | stretch;</span><br><span class="line">place-self: &lt;align-self&gt; &lt;justify-self&gt;;</span><br></pre></td></tr></table></figure>

<h2 id="四、兼容性"><a href="#四、兼容性" class="headerlink" title="四、兼容性"></a>四、兼容性</h2><p>之所以这么强大的grid布局没有普及和其兼容性有很大的关系。现在的主流的几家浏览器其实都支持了，但是在ie、qq浏览器、百度浏览器和opera mini都还不支持或者不太支持（2019/10/21）<br><a href="https://caniuse.com/#search=grid" target="_blank" rel="noopener">Can I Use</a></p>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>layout</tag>
      </tags>
  </entry>
  <entry>
    <title>jshint</title>
    <url>/2017/08/31/jshint/</url>
    <content><![CDATA[<h2>jshint  静态代码检测工具</h2>

<blockquote>
<p>参考地址：<a href="http://jshint.com/docs/" target="_blank" rel="noopener">http://jshint.com/docs/</a></p>
</blockquote>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install jshint -g</span><br></pre></td></tr></table></figure>

<h3 id="项目中有可能用到的文件："><a href="#项目中有可能用到的文件：" class="headerlink" title="项目中有可能用到的文件："></a>项目中有可能用到的文件：</h3><ul>
<li>.jshintrc jshint配置文件／或者用–config命令 指定一个.json文件</li>
<li>.jshintignore jshint不忽略检测的文件 ／ 或者用 –exclude-path命令指定一个.gitignore</li>
<li>reporter.js 自定义的jshint的输出方法，具体可参考本文的 <a href="#reporter">附件:reporter</a><a id="more"></a>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="ide拓展"><a href="#ide拓展" class="headerlink" title="ide拓展"></a>ide拓展</h4>主流的ide都有自己的拓展插件，这里用vscode简单的说明。<br>在vscode左侧的应用商店搜索jshint排第一个就是。配合项目中的.jshintrc文件可以在ide中报错。</li>
</ul>
<h4 id="jshint-CLI"><a href="#jshint-CLI" class="headerlink" title="jshint CLI"></a>jshint CLI</h4><p>jshint自带命令行</p>
<table>
<thead>
<tr>
<th>例子</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>jshint myfile.js</td>
<td>执行jshint</td>
</tr>
<tr>
<td>jshint –reporter=myreporter.js myfile.js</td>
<td>定义reporter</td>
</tr>
<tr>
<td>jshint –verbose myfile.js</td>
<td>输出中加入错误码</td>
</tr>
<tr>
<td>jshint –show-non-errors myfile.js</td>
<td>输出中加入错误信息</td>
</tr>
<tr>
<td>jshint –exclude path</td>
<td>加入不想被linted的目录</td>
</tr>
<tr>
<td>jshint –exclude-path</td>
<td>指定.jshintignore</td>
</tr>
<tr>
<td>–prereq</td>
<td>指定全局变量</td>
</tr>
<tr>
<td>jshint –help</td>
<td>帮助</td>
</tr>
<tr>
<td>jshint –version</td>
<td>版本</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<h5 id="屏蔽某些错误提示"><a href="#屏蔽某些错误提示" class="headerlink" title="屏蔽某些错误提示"></a>屏蔽某些错误提示</h5><p>jshint提供了option选项去根据不同的项目需求和程序员习惯开启或屏蔽一些错误或警告提示。但是还是有些提示并不能通过配置去掉。（这有点烦人。。）这时可以用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* jshint -W034 */</span><br></pre></td></tr></table></figure>

<p>去除对应的警告。这个W034就是错误码。具体怎么得到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jshint --verbose myfile.js</span><br><span class="line">myfile.js: line 6, col 3, Unnecessary directive &quot;use strict&quot;. (W034)</span><br></pre></td></tr></table></figure>

<p>或者有些ide的提示也会直接提示你错误码。（note： 一般警告的错误码会以W开头，错误的错误码会以E开头）<br>如果你想重新启动被屏蔽的错误那就用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* jshint +W034 */</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">[rectangle</span> <span class="attr">setX:</span> <span class="number">10</span> <span class="attr">y:</span> <span class="number">10</span> <span class="attr">width:</span> <span class="number">20</span> <span class="attr">height:</span> <span class="number">20</span><span class="string">];</span></span><br></pre></td></tr></table></figure>

<h2 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h2><p>按照顺序依次查找以下的config配置：</p>
<ul>
<li>通过jshint –config  ..path/myconfig.json指定config</li>
<li>在package.json里增加一个jshintConfig属性，在属性里配置参数。</li>
<li>在项目根目录添加一个.jshintrc的json配置文件，jshint运行是会从代码文件目录往上寻找直到找到.jshintrc文件。都找不到会在全局的默认配置里找.jshintrc文件。</li>
</ul>
<h2 id="Inline-configuration"><a href="#Inline-configuration" class="headerlink" title="Inline configuration"></a>Inline configuration</h2><p>除了以上三种方法jshint还支持行内配置。<br>类似这样，在文件或函数开头加入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* jshint undef: true, unused: true */</span><br><span class="line">/* globals MY_GLOBAL */</span><br></pre></td></tr></table></figure>

<p>行内配置有以下几种方式：</p>
<p><strong>jshint开头，多个选项以逗号分开</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* jshint strict: true */</span><br></pre></td></tr></table></figure>

<p><strong>globals开头，标识全局变量避免启用undef选项时应用未定义变量报错</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* globals MY_LIB: false */</span><br></pre></td></tr></table></figure>

<p><strong>exported，标识全局变量避免启用unused选项时变量未使用报错</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* exported EXPORTED_LIB */</span><br></pre></td></tr></table></figure>

<p><strong>ignore，ignore中的代码不做jshint检测</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Code here will be linted with JSHint.</span><br><span class="line">/* jshint ignore:start */</span><br><span class="line">// Code here will be ignored by JSHint.</span><br><span class="line">/* jshint ignore:end */</span><br></pre></td></tr></table></figure>

<p><strong>falls through, 避免Switch statements 没有break报错</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">switch (cond) &#123;</span><br><span class="line">    case &quot;one&quot;:</span><br><span class="line">        doSomething(); // JSHint will warn about missing &apos;break&apos; here.</span><br><span class="line">        /* falls through */</span><br><span class="line">    case &quot;two&quot;:</span><br><span class="line">        doSomethingElse();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="jshintrc参数"><a href="#jshintrc参数" class="headerlink" title="jshintrc参数"></a>jshintrc参数</h2><blockquote>
<p>参考<a href="http://jshint.com/docs/options/" target="_blank" rel="noopener">http://jshint.com/docs/options/</a></p>
</blockquote>
<p>具体的参数可以参考上面的官方文档。这里不做多介绍。</p>
<p>一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    //加强选项：</span><br><span class="line"></span><br><span class="line">    //use es6. 3/5/6</span><br><span class="line">    &quot;esversion&quot;: 6,</span><br><span class="line"></span><br><span class="line">    //循环必须用大括号包起来</span><br><span class="line">    &quot;curly&quot;: true,</span><br><span class="line"></span><br><span class="line">    //设置为true,禁止使用这个选项 ==和 !=，强制使用 ===和 !==。</span><br><span class="line">    &quot;eqeqeq&quot;: false,</span><br><span class="line"></span><br><span class="line">    //允许警告js未来版本中定义的标识符。</span><br><span class="line">    &quot;futurehostile&quot;: true,</span><br><span class="line"></span><br><span class="line">    //检查无效 typeof操作符的值</span><br><span class="line">    &quot;notypeof&quot;: true,</span><br><span class="line"></span><br><span class="line">    //检查变量重复定义</span><br><span class="line">    // 他接受4个值：&quot;inner&quot; 只检查是否在相同的作用域重复定义;&quot;outer&quot; 检查外部作用域;</span><br><span class="line">    // false 与inne一样; true 允许变量覆盖</span><br><span class="line">    &quot;shadow&quot;: &quot;inner&quot;,</span><br><span class="line"></span><br><span class="line">    //ECMAScript 5严格模式</span><br><span class="line">    // &quot;global&quot; - 全局层面的严格模式&quot;use strict&quot;;</span><br><span class="line">    // &quot;implied&quot; - 文件里面使用&quot;use strict&quot;;</span><br><span class="line">    // false - 禁止使用严格模式</span><br><span class="line">    // true - 函数上面必须使用一个&quot;use strict&quot;; </span><br><span class="line">    &quot;strict&quot;: &quot;implied&quot;,</span><br><span class="line"></span><br><span class="line">    //变量未定义</span><br><span class="line">    &quot;undef&quot;: true,</span><br><span class="line"></span><br><span class="line">    //变量定义未使用</span><br><span class="line">    &quot;unused&quot;: true,</span><br><span class="line"></span><br><span class="line">    // 设置为true时，禁止使用var声明变量</span><br><span class="line">    // &quot;varstmt&quot;: true,</span><br><span class="line"></span><br><span class="line">    // &quot;globals&quot;: &#123;</span><br><span class="line">    //     &quot;require&quot;: true</span><br><span class="line">    // &#125;,</span><br><span class="line"></span><br><span class="line">    //宽松选项：</span><br><span class="line"></span><br><span class="line">    // 禁止缺少分号警告</span><br><span class="line">    &quot;asi&quot;: true,</span><br><span class="line"></span><br><span class="line">    //环境选项：</span><br><span class="line">    //暴露浏览器属性的全局变量，列如 window,document;</span><br><span class="line">    //注意:这个选项不暴露变量 alert或 console。</span><br><span class="line">    &quot;browser&quot;: true,</span><br><span class="line"></span><br><span class="line">    //这个选项定义了全局变量,通常用于日志调试: console, alert等等</span><br><span class="line">    &quot;devel&quot;: true,</span><br><span class="line"></span><br><span class="line">    //这个选项定义全局变量可以当你的代码运行在node的运行时环境</span><br><span class="line">    &quot;node&quot;: true,</span><br><span class="line"></span><br><span class="line">    //这个选项告诉JSHint,输入代码描述了一个ECMAScript 6模块。所有模块的代码解释为严格模式代码。</span><br><span class="line">    &quot;module&quot;: true,</span><br><span class="line"></span><br><span class="line">    //这个选项定义全局暴露的jQuery库。</span><br><span class="line">    &quot;jquery&quot;: true</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里要说的是option里除了加强选项，宽松选项，环境选项还有一些特殊选项：<br><strong>entend</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;extends&quot;: &quot;../.jshintrc&quot;,</span><br><span class="line">  &quot;globals&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: false,</span><br><span class="line">    &quot;assert&quot;: false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//在一些情况下你可能想要在项目配置之外加载一些已有的配置</span><br></pre></td></tr></table></figure>

<p><strong>overrides</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;shadow&quot;: false,</span><br><span class="line">  &quot;overrides&quot;: &#123;</span><br><span class="line">    &quot;lib/*-test.js&quot;: &#123;</span><br><span class="line">      &quot;expr&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//在不同的文件中应用不同的配置</span><br></pre></td></tr></table></figure>

<h2 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h2><h3 id="reporter">reporters</h3>

<p>JSHint Reporter.js是一个你自定义的代替jshint默认输出方法的文件。<br>用jshint命令可以执行你的reporter</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jshint --reporter=myreporter.js myfile.js</span><br></pre></td></tr></table></figure>

<p>下面是一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  reporter: function (res) &#123;</span><br><span class="line">    var len = res.length;</span><br><span class="line">    var str = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    res.forEach(function (r) &#123;</span><br><span class="line">      var file = r.file;</span><br><span class="line">      var err = r.error;</span><br><span class="line"></span><br><span class="line">      str += file + &quot;: line &quot; + err.line + &quot;, col &quot; +</span><br><span class="line">        err.character + &quot;, &quot; + err.reason + &quot;\n&quot;;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    if (str) &#123;</span><br><span class="line">      process.stdout.write(str + &quot;\n&quot; + len + &quot; error&quot; +</span><br><span class="line">        ((len === 1) ? &quot;&quot; : &quot;s&quot;) + &quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的例子中res中存的error的格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    file: &apos;demo.js&apos;,</span><br><span class="line">    error:  &#123;</span><br><span class="line">      id: &apos;(error)&apos;,</span><br><span class="line">      code: &apos;W117&apos;,</span><br><span class="line">      reason: &apos;\&apos;module\&apos; is not defined.&apos;</span><br><span class="line">      evidence: &apos;module.exports = &#123;&apos;,</span><br><span class="line">      line: 3,</span><br><span class="line">      character: 1,</span><br><span class="line">      scope: &apos;(main)&apos;,</span><br><span class="line"></span><br><span class="line">      // [...]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // [...]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>如果你想用exporter禁止报某些错误的话可以写个判断，error.code === ‘Wxxx’ 时 return。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>jshint</tag>
      </tags>
  </entry>
  <entry>
    <title>yarn介绍</title>
    <url>/2017/08/31/yarn/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://github.com/yarnpkg/yarn" target="_blank" rel="noopener">yarn</a> - <a href="https://github.com/yarnpkg/yarn" target="_blank" rel="noopener">https://github.com/yarnpkg/yarn</a></p>
</blockquote>
<h2 id="一、为什么需要yarn"><a href="#一、为什么需要yarn" class="headerlink" title="一、为什么需要yarn"></a>一、为什么需要yarn</h2><p>   作为一个前端，说到包管理首先想到的可能是node里的npm。至今为止，它可以访问在npm注册的 300,000 多个安装包。超出500万的工程师使用npm注册，每个月的下载量高达 50 亿<a id="more"></a>但是随着npm的普遍过程中，有一些问题也随之暴露出来：</p>
<ol>
<li>当跨机器或用户安装依赖时，拉取依赖包消耗的时间较长（依赖网络）。</li>
<li>在版本管理没用锁定的情况下一个小升级就有可能导致项目出错。</li>
<li>在协作开发时，npm安装依赖到  node_modules 目录时顺序不是固定的，不能保证不同终端中的开发环境一致。</li>
<li>node_modules里的依赖有很多重复的，即占用了硬盘资源，又拉长了拉取的时间和网络资源。<br>所以yarn诞生了。</li>
</ol>
<h2 id="二、yarn简介"><a href="#二、yarn简介" class="headerlink" title="二、yarn简介"></a>二、yarn简介</h2><p>facebook于 2016-10-12 开源的javascript包管理工具 Yarn，开源三天star数就超过了npm。Yarn 作为一个新的包管理器，用于替代现有的 npm 客户端或者其他兼容 npm 仓库的包管理工具。Yarn 保留了现有工作流的特性，优点是更快、更安全、更可靠。</p>
<blockquote>
<p>新的特性：</p>
</blockquote>
<ol>
<li>离线模式（Offline Mode）：如果你之前安装过某个包，那么你可以在没有互联网连接的情况下，对这个包进行重新安装。</li>
<li>确定性（Deterministic）：不管安装顺序如何，相同的依赖在每台机器上会以完全相同的方式进行安装。</li>
<li>网络性能：Yarn会对请求进行高效地排队，避免出现请求瀑布（waterfall），便于将网络的使用效率达到最大化。</li>
<li>网络弹性（Network Resilience）：单个请求的失败不会导致整个安装的失败，请求会基于故障进行重试。</li>
<li>扁平模式（Flat Mode）：将不匹配的依赖版本都会解析为同一个版本，避免重复创建。</li>
</ol>
<p>总结一下就是：兼容npm、缓存和离线下载、yarn.lock锁定版本与安装顺序</p>
<h2 id="三、yarn的使用"><a href="#三、yarn的使用" class="headerlink" title="三、yarn的使用"></a>三、yarn的使用</h2><p>安装<br><strong>macOS</strong><br>官方推荐的是homebrew：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install yarn</span><br></pre></td></tr></table></figure>

<p>或者用npm也可以：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g yarn</span><br></pre></td></tr></table></figure>

<p><strong>windows</strong><br>下载.msi文件安装 ( <a href="https://yarnpkg.com/latest.msi" target="_blank" rel="noopener">下载传送门</a> )，不过需要先装个node ( <a href="https://nodejs.org/" target="_blank" rel="noopener">下载传送门</a> ).<br><strong>Linux</strong><br>apt-get:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update &amp;&amp; sudo apt-get install yarn</span><br></pre></td></tr></table></figure>

<p>yum:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install yarn</span><br></pre></td></tr></table></figure>

<p>and so on…</p>
<p>简单指令</p>
<table>
<thead>
<tr>
<th>npm</th>
<th>yarn</th>
<th>注释</th>
</tr>
</thead>
<tbody><tr>
<td>npm init</td>
<td>yarn init</td>
<td></td>
</tr>
<tr>
<td>npm install</td>
<td>yarn / yarn install</td>
<td></td>
</tr>
<tr>
<td>npm install xxx —save</td>
<td>yarn add xxx</td>
<td>yarn add [package]@[version]</td>
</tr>
<tr>
<td>npm uninstall xxx —save</td>
<td>yarn remove xxx</td>
<td></td>
</tr>
<tr>
<td>npm update</td>
<td>yarn upgrade</td>
<td>yarn upgrade [package]@[version]</td>
</tr>
<tr>
<td>npm install xxx -g</td>
<td>yarn global add xxx</td>
<td></td>
</tr>
</tbody></table>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>如果你只是想本地改一下依赖就用npm好了，yarn每次更改好像都会更改.lock文件。如果并不想锁定版本用npm也是一种可接受方案。</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>node</tag>
        <tag>npm</tag>
        <tag>yarn</tag>
      </tags>
  </entry>
</search>
